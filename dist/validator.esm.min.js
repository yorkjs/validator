const{toString:t}=Object.prototype;function e(e){return t.call(e).toLowerCase().slice(8,-1)}function n(t){return!(!t||"object"!==e(t))}function r(t,n){if(!Array.isArray(n))return"type";const{length:r}=n;if(void 0!==t.min&&r<t.min)return"min";if(void 0!==t.max&&r>t.max)return"max";const{itemType:i}=t;if(i)for(let t=0;t<r;t++)if(e(n[t])!==i)return"itemType"}function i(t,e){return"boolean"!=typeof e?"type":void 0!==t.value&&t.value!==e?"value":void 0}function s(t,e){if("string"!=typeof e)return"type";if(""===e){if(!0===t.empty)return;return"empty"}if(void 0!==t.min&&e.length<t.min)return"min";if(void 0!==t.max&&e.length>t.max)return"max";if(void 0!==t.pattern&&!t.pattern.test(e))return"pattern";if(void 0!==t.custom){const n=t.custom(e);if(n)return n}}const o=/^\d{4}\-\d{2}\-\d{2}$/;function a(t,e){const n={};return Object.assign(n,t),Object.assign(n,{type:"string",pattern:o}),s(n,e)}const u=/^\d{4}\-\d{2}\-\d{2} \d{2}:\d{2}:\d{2}$/;function c(t,e){const n={};return Object.assign(n,t),Object.assign(n,{type:"string",pattern:u}),s(n,e)}function f(t,e){if(!Array.isArray(t.values)||t.values.indexOf(e)<0)return"type"}function m(t,e){return"number"!=typeof e||e%1!=0?"type":void 0!==t.min&&e<t.min?"min":void 0!==t.max&&e>t.max?"max":void 0}function p(t,e){return"number"!=typeof e||isNaN(e)?"type":void 0!==t.min&&e<t.min?"min":void 0!==t.max&&e>t.max?"max":void 0}function y(t,e){if(!n(e))return"type"}class d{constructor(){this.rules={int:m,integer:m,number:p,string:s,bool:i,boolean:i,enum:f,array:r,object:y,date:a,dateTime:c},this.messages={}}add(t,e,r){n(t)?(Object.assign(this.rules,t),n(e)&&Object.assign(this.messages,e)):(this.rules[t]=e,this.messages[t]=r)}validate(t,r,i){let s;for(let o in r){const a=r[o];let u,c;switch(e(a)){case"string":u={type:a};break;case"array":u={type:"enum",values:a};break;case"regexp":u={type:"string",pattern:a};break;default:u=a}if(!n(u)||!u.type)throw new Error(`${o}'s rule is not found.`);if(t.hasOwnProperty(o))c=this.rules[u.type](u,t[o],t);else{if(!1===u.required)continue;c="required"}if(c){let t=i&&i[o]&&i[o][c];switch("string"!=typeof t&&"function"!=typeof t&&(t=this.messages[u.type]&&this.messages[u.type][c]),s||(s={}),typeof t){case"string":s[o]=t;break;case"function":s[o]=t(u);break;default:s[o]=c}}}return s}}const l="0.0.2";export{d as Validator,r as checkArray,i as checkBoolean,a as checkDate,c as checkDateTime,f as checkEnum,m as checkInteger,p as checkNumber,y as checkObject,s as checkString,l as version};
//# sourceMappingURL=validator.esm.min.js.map

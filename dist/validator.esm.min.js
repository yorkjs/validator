const{toString:e}=Object.prototype;function r(r){return e.call(r).toLowerCase().slice(8,-1)}function t(e){return!(!e||"object"!==r(e))}function n(e,r){for(let t in r)e[t]=r[t]}function i(e,t){if(!Array.isArray(t))return{rule:e,reason:"type"};const{length:n}=t;if(void 0!==e.min&&n<e.min)return{rule:e,reason:"min"};if(void 0!==e.max&&n>e.max)return{rule:e,reason:"max"};const{itemType:i}=e;if(i)for(let o=0;o<n;o++)if(r(t[o])!==i)return{rule:e,reason:"itemType"}}function o(e,r){return"boolean"!=typeof r?{rule:e,reason:"type"}:void 0!==e.value&&e.value!==r?{rule:e,reason:"value"}:void 0}function s(e,r){if("string"!=typeof r)return{rule:e,reason:"type"};if(""===r){if(!0===e.empty)return;return{rule:e,reason:"empty"}}if(void 0!==e.min&&r.length<e.min)return{rule:e,reason:"min"};if(void 0!==e.max&&r.length>e.max)return{rule:e,reason:"max"};if(void 0!==e.pattern&&!e.pattern.test(r))return{rule:e,reason:"pattern"};if(void 0!==e.custom){const t=e.custom(r);if(t)return{rule:e,reason:t}}}const u=/^\d{4}\-\d{2}\-\d{2}$/;function a(e,r){const t={};return n(t,e),n(t,{type:"string",pattern:u}),s(t,r)}const l=/^\d{4}\-\d{2}\-\d{2} \d{2}:\d{2}:\d{2}$/;function f(e,r){const t={};return n(t,e),n(t,{type:"string",pattern:l}),s(t,r)}function c(e,r){if(!Array.isArray(e.values)||e.values.indexOf(r)<0)return{rule:e,reason:"type"}}function m(e,r){return"number"!=typeof r||r%1!=0?{rule:e,reason:"type"}:void 0!==e.min&&r<e.min?{rule:e,reason:"min"}:void 0!==e.max&&r>e.max?{rule:e,reason:"max"}:void 0}function p(e,r){if("number"!=typeof r||isNaN(r))return{rule:e,reason:"type"};if(void 0!==e.min&&r<e.min)return{rule:e,reason:"min"};if(void 0!==e.max&&r>e.max)return{rule:e,reason:"max"};if(void 0!==e.precision){const t=(""+r).split(".");if(2===t.length&&t[1].length>e.precision)return{rule:e,reason:"precision"}}}function d(e,r){if(!t(r))return{rule:e,reason:"type"}}class y{constructor(){this.rules={int:m,integer:m,number:p,string:s,bool:o,boolean:o,enum:c,array:i,object:d,date:a,dateTime:f},this.messages={}}add(e,r,i){t(e)?(n(this.rules,e),t(r)&&n(this.messages,r)):(this.rules[e]=r,this.messages[e]=i)}validate(e,n,i){let o;for(let s in n){const u=n[s];let a,l;switch(r(u)){case"string":a={type:u};break;case"array":a={type:"enum",values:u};break;case"regexp":a={type:"string",pattern:u};break;default:a=u}if(!t(a)||!a.type)throw new Error(`${s}'s rule is not found.`);if(void 0!==e[s])l=this.rules[a.type](a,e[s],e);else{if(!1===a.required)continue;l={rule:a,reason:"required"}}if(l){let e=i&&i[s]&&i[s][l.reason];switch("string"!=typeof e&&"function"!=typeof e&&(e=this.messages[a.type]&&this.messages[a.type][l.reason]),o||(o={}),typeof e){case"string":o[s]=e;break;case"function":o[s]=e(l.rule);break;default:o[s]=l.reason}}}return o}}const v="0.1.0";export{y as Validator,i as checkArray,o as checkBoolean,a as checkDate,f as checkDateTime,c as checkEnum,m as checkInteger,p as checkNumber,d as checkObject,s as checkString,v as version};
//# sourceMappingURL=validator.esm.min.js.map

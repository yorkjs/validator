const{toString:t}=Object.prototype;function e(e){return t.call(e).toLowerCase().slice(8,-1)}function n(t){return!(!t||"object"!==e(t))}function i(t,e){for(let n in e)t[n]=e[n]}function r(t,n){if(!Array.isArray(n))return"type";const{length:i}=n;if(void 0!==t.min&&i<t.min)return"min";if(void 0!==t.max&&i>t.max)return"max";const{itemType:r}=t;if(r)for(let t=0;t<i;t++)if(e(n[t])!==r)return"itemType"}function o(t,e){return"boolean"!=typeof e?"type":void 0!==t.value&&t.value!==e?"value":void 0}function s(t,e){if("string"!=typeof e)return"type";if(""===e){if(!0===t.empty)return;return"empty"}if(void 0!==t.min&&e.length<t.min)return"min";if(void 0!==t.max&&e.length>t.max)return"max";if(void 0!==t.pattern&&!t.pattern.test(e))return"pattern";if(void 0!==t.custom){const n=t.custom(e);if(n)return n}}const u=/^\d{4}\-\d{2}\-\d{2}$/;function a(t,e){const n={};return i(n,t),i(n,{type:"string",pattern:u}),s(n,e)}const f=/^\d{4}\-\d{2}\-\d{2} \d{2}:\d{2}:\d{2}$/;function c(t,e){const n={};return i(n,t),i(n,{type:"string",pattern:f}),s(n,e)}function m(t,e){if(!Array.isArray(t.values)||t.values.indexOf(e)<0)return"type"}function p(t,e){return"number"!=typeof e||e%1!=0?"type":void 0!==t.min&&e<t.min?"min":void 0!==t.max&&e>t.max?"max":void 0}function d(t,e){if("number"!=typeof e||isNaN(e))return"type";if(void 0!==t.min&&e<t.min)return"min";if(void 0!==t.max&&e>t.max)return"max";if(void 0!==t.precision){const n=(""+e).split(".");if(2===n.length&&n[1].length>t.precision)return"precision"}}function l(t,e){if(!n(e))return"type"}class y{constructor(){this.rules={int:p,integer:p,number:d,string:s,bool:o,boolean:o,enum:m,array:r,object:l,date:a,dateTime:c},this.messages={}}add(t,e,r){n(t)?(i(this.rules,t),n(e)&&i(this.messages,e)):(this.rules[t]=e,this.messages[t]=r)}validate(t,i,r){let o;for(let s in i){const u=i[s];let a,f;switch(e(u)){case"string":a={type:u};break;case"array":a={type:"enum",values:u};break;case"regexp":a={type:"string",pattern:u};break;default:a=u}if(!n(a)||!a.type)throw new Error(`${s}'s rule is not found.`);if(void 0!==t[s])f=this.rules[a.type](a,t[s],t);else{if(!1===a.required)continue;f="required"}if(f){let t=r&&r[s]&&r[s][f];switch("string"!=typeof t&&"function"!=typeof t&&(t=this.messages[a.type]&&this.messages[a.type][f]),o||(o={}),typeof t){case"string":o[s]=t;break;case"function":o[s]=t(a);break;default:o[s]=f}}}return o}}const v="0.0.5";export{y as Validator,r as checkArray,o as checkBoolean,a as checkDate,c as checkDateTime,m as checkEnum,p as checkInteger,d as checkNumber,l as checkObject,s as checkString,v as version};
//# sourceMappingURL=validator.esm.min.js.map
